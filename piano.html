<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>PIANO</title>
    <link rel="stylesheet" type="text/css" href="assets/css/piano.css" />
    <script src="assets/js/jquery-3.7.1.min.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="keyboard"></div>
    </div>

    <script>
      class Score {
        constructor() {
          this.score = [];
        }
        add(note, octave, length) {
          this.score.push({ note: note, octave: octave, length: length });
          return this;
        }
      }
      class Instrument {
        /**
         * @param {number} num - 鍵盤の数
         * @param {AudioContext} audio - AudioContext
         * @param {JQuery} key_jquery - 挿入するHTMLの場所
         * @param {number} initial_octave - 最初のオクターブ
         * @param {number} shift - 鍵盤の開始位置の移動
         */
        constructor(num, audio, key_jquery, initial_octave = 0, shift = 0) {
          this.shift = shift;
          num = num + shift;

          this.audio = audio;
          this.key_jquery = key_jquery;

          this.osc_list = [];

          this.main_gain_node = this.audio.createGain();
          this.main_gain_node.connect(this.audio.destination);
          this.main_gain_node.gain.value = 1;

          const r = Math.pow(2, 1 / 12);
          this.notes = [];
          this.initial_octave = initial_octave;
          this.max_octave = Math.ceil((num - 2) / 12) + initial_octave;
          this.scale = [
            "ラ",
            "ラ#",
            "シ",
            "ド",
            "ド#",
            "レ",
            "レ#",
            "ミ",
            "ファ",
            "ファ#",
            "ソ",
            "ソ#",
          ];
          this.notes[0] = {
            freq: 27.5 * 2 ** this.initial_octave,
            note: "ラ",
            octave: this.initial_octave,
          };
          for (let i = 1; i < num; i++) {
            this.notes[i] = {
              freq: this.notes[i - 1]["freq"] * r,
              note: this.scale[i % 12],
              octave: Math.ceil((i - 2) / 12) + initial_octave,
            };
          }
          this.create_key();
        }

        create_key() {
          this.notes.splice(0, this.shift);
          this.notes.forEach((value, index) => {
            this.key_jquery.append(
              $("<div></div>")
                .data(value)
                .addClass(value.note)
                .addClass(`key`)
                .append($("<p></p>").text(value.note))
                .on("mousedown", (event) => this.note_pressed(event))
                .on("mouseup", (event) => this.note_released(event))
                .on("mouseover", (event) => this.note_pressed(event))
                .on("mouseleave", (event) => this.note_released(event))
            );
          });
        }

        note_pressed(event) {
          if (event.buttons & 1) {
            const target = $(event.target);
            const dataset = target.data();

            if (!dataset["pressed"]) {
              this.osc_list[dataset["index"]] = this.play_tone(
                dataset["freq"],
                this.audio.currentTime,
                5
              );
              target.data("pressed", true);
              this.show_display(dataset["note"]);
            }
          }
        }

        note_released(event) {
          const target = $(event.target);
          const dataset = target.data();

          if (dataset["pressed"]) {
            if (this.osc_list[dataset["index"]]) {
              this.stop_tone(this.osc_list[dataset["index"]]);
              this.osc_list[dataset["index"]] = null;
              target.data("pressed", false);
              this.show_display();
            }
          }
        }

        stop_tone(osc_and_gain) {
          const release_time = 0.1;
          const now = this.audio.currentTime;
          osc_and_gain.gainNode.gain.cancelAndHoldAtTime(now);
          osc_and_gain.gainNode.gain.linearRampToValueAtTime(
            0,
            now + release_time
          );
          osc_and_gain.osc.stop(now + release_time + 0.1);
        }

        play_tone(freq, time, length) {
          const attack_time = 0.1;
          const release_time = 0.1;
          const osc = this.audio.createOscillator();
          osc.type = "sine";

          const gainNode = this.audio.createGain();
          gainNode.gain.setValueAtTime(0, time);
          gainNode.gain.linearRampToValueAtTime(0.5, time + attack_time);
          gainNode.gain.linearRampToValueAtTime(
            0,
            time + length + release_time
          );

          osc.connect(gainNode).connect(this.main_gain_node);
          osc.frequency.value = freq;
          osc.start(time);
          osc.stop(time + length + release_time);
          return { osc, gainNode };
        }

        /** @param {JQuery} jq */
        create_display(jq) {
          this.display = $("<div></div>").addClass(`display`);
          jq.after(this.display);
        }
        show_display(text = "") {
          this.display.text(text);
        }

        create_auto_play_button(jq) {
          this.auto_play_button = $("<input>")
            .addClass(`auto_play_button`)
            .prop("type", "button")
            .prop("value", "自動演奏")
            .on("click", () => this.press_auto_play_button(score));
          jq.after(this.auto_play_button);
        }

        press_auto_play_button(score) {
          this.auto_play(score);
        }

        /** @param {Score} score */
        auto_play(score) {
          const schedule_ahead_time = 0.1;
          const now = this.audio.currentTime;
          let next_note_time = now;
          score.score.forEach((value) => {
            let note = this.notes.find(
              ({ note, octave }) =>
                note === value.note && octave === value.octave
            );
            if (note === undefined) {
              this.play_tone(0, next_note_time, value.length);
            } else {
              this.play_tone(note["freq"], next_note_time, value.length);
            }
            next_note_time += value.length;
            while (
              next_note_time <
              this.audio.currentTime + schedule_ahead_time
            ) {}
          });
        }
      }
    </script>
    <script>
      const audioContext = new AudioContext();
      let score = new Score();
      score
        .add("ド", 4, 0.5)
        .add("レ", 4, 0.5)
        .add("ミ", 4, 1)
        .add("ド", 4, 0.5)
        .add("レ", 4, 0.5)
        .add("ミ", 4, 1)
        .add("ソ", 4, 0.5)
        .add("ミ", 4, 0.5)
        .add("レ", 4, 0.5)
        .add("ド", 4, 0.5)
        .add("レ", 4, 0.5)
        .add("ミ", 4, 0.5)
        .add("レ", 4, 1);
      let piano = new Instrument(80, audioContext, $(".keyboard"), 0, 3);
      piano.create_display($(".container"));
      piano.create_auto_play_button($(".container"));
    </script>
  </body>
</html>
